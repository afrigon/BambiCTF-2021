#!/usr/bin/env python1

from pwn import *
import requests
import json
import re
import time
import os
from multiprocessing.dummy import Pool as ThreadPool
import importlib

# Logging configuration
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

original_info = log.info
log.info = lambda x: original_info(bcolors.OKBLUE + x + bcolors.ENDC)
log.header = lambda x: original_info(bcolors.HEADER + x + bcolors.ENDC)

original_success = log.success
log.success = lambda x: original_success(bcolors.OKGREEN + x + bcolors.ENDC)

original_failure = log.failure
log.failure = lambda x: original_failure(bcolors.FAIL + x + bcolors.ENDC)
log.fail_once = lambda x, errors_in_round: x in errors_in_round or log.failure(x)

# Submission server URL
SUBMISSION_URL = "10.0.13.37"
SUBMISSION_PORT = 1337

# Flag id server URL
ATTACC_URL = "https://bambi6.enoflag.de/scoreboard/attack.json"

# Message types
NOT_RECOGNIZED      = "Flag not recognized"
TEAPOT              = "418 I'm a teapot!"
NO_SUCH_FLAG        = "No such Flag"
EXPIRED             = "Flag expired since"
INVALID_CHARS       = "Flags should be of the Format"
OWN_FLAG            = "Can't submit a flag for your own team"
ACCEPTED            = "Thank you for your submission!"
ERRORED             = "INV"
CONTEST_NOT_STARTED = "Contest didn't even start yet!"
CONTEST_OVER        = "Contest already over!"

# Delays and timeouts
REQUEST_TIMEOUT     = 5 # HTTP Request timeouts (in seconds)
RECONNECT_DELAY     = 3 # Delay before attempting a new connection (in seconds)

# Miscellaneous
EXPLOIT_FOLDER      = "exploits"

def is_valid_flag(flag):
    """
    Checks if a string matches the flag format
    """
    return False if re.match("^ENO_[A-Za-z0-9/\\+]{48}$", flag) is None else True

def remove_invalid_flags(flags):
    """
    Takes a list of flags and removes flags with an invalid format
    Returns a list of valid flags (format-wise)
    """

    # Validate flag format
    filtered_flags = [flag for flag in flags if is_valid_flag(flag)]

    number_of_removed_flags = len(flags) - len(filtered_flags)

    if number_of_removed_flags:
        log.failure("Removed {} flags with incorrect format.".format(number_of_removed_flags))

    return filtered_flags

def print_statistics_from_flag_responses(flag_responses, flags_per_handler):

    stats = {}

    for handler in flags_per_handler.keys():
        stats[handler] = {
            "number_of_invalid_flags" : 0,
            "number_of_own_flags" : 0,
            "number_of_expired_flags" : 0,
            "number_of_accepted_flags" : 0,
        }

    for response in flag_responses:

        current_handler = None

        # Find which handler submitted a given flag
        for handler in flags_per_handler.keys():

            if response['flag'] in flags_per_handler[handler]:
                current_handler = handler

        if not current_handler:
            log.failure("Server responded with a flag that we have never submitted : {}".format(
                response['flag']))
            continue

        if response['message_type'] in [NOT_RECOGNIZED, NO_SUCH_FLAG, ERRORED, TEAPOT, INVALID_CHARS]:
            stats[current_handler]['number_of_invalid_flags'] += 1

        elif response['message_type'] == OWN_FLAG:
            stats[current_handler]['number_of_own_flags'] += 1

        elif response['message_type'] == EXPIRED:
            stats[current_handler]['number_of_expired_flags'] += 1

        elif response['message_type'] == ACCEPTED:
            stats[current_handler]['number_of_accepted_flags'] += 1

        else:
            log.failure("Invalid message received : '{}'".format(response['flag_response']))

    log.header("==== ROUND STATISTICS ===")
    for handler in stats.keys():
        number_of_invalid_flags = stats[handler]['number_of_invalid_flags']
        number_of_own_flags = stats[handler]['number_of_own_flags']
        number_of_expired_flags = stats[handler]['number_of_expired_flags']
        number_of_accepted_flags = stats[handler]['number_of_accepted_flags']

        log.header("{:30} | {:7} | {:3} | {:7} | {:8} |".format("Handler name",
            "Invalid", "Own", "Expired", "Accepted"))

        log.header("{:30} | {:7} | {:3} | {:7} | {:8} |".format(handler,
            number_of_invalid_flags, number_of_own_flags, number_of_expired_flags,
            number_of_accepted_flags))

def parse_response(flag_response, flag):
    """
    Parses each individual flag response returned from submit_flags()
    Returns a dictionary containing { flag, message_type }
    """

    if NO_SUCH_FLAG in flag_response:
        message_type = NO_SUCH_FLAG

    if OWN_FLAG in flag_response:
        message_type = OWN_FLAG

    if ERRORED in flag_response:
        message_type = ERRORED

    if NOT_RECOGNIZED in flag_response:
        message_type = NOT_RECOGNIZED

    if CONTEST_NOT_STARTED in flag_response:
        message_type = CONTEST_NOT_STARTED

    if CONTEST_OVER in flag_response:
        message_type = CONTEST_OVER

    if INVALID_CHARS in flag_response:
        message_type = INVALID_CHARS

    if EXPIRED in flag_response:
        message_type = EXPIRED

    if TEAPOT in flag_response:
        message_type = TEAPOT

    if ACCEPTED in flag_response:
        message_type = ACCEPTED

    return {
        "flag" : flag,
        "message_type" : message_type,
        "flag_response": flag_response,
    }

def submit_flags(flags = []):
    """
    Submit flags to the submission server and parses the responses.
    Returns the parsed flag responses.
    """

    log.success("Submitting {} flags.".format(len(flags)))

    # Loop until we receive a response from the submission server
    while True:
        try:
            p = remote(SUBMISSION_URL, SUBMISSION_PORT)
            #p.recvuntil("One flag per line please!\n", REQUEST_TIMEOUT)
            responses = []

            for flag in flags:
                p.sendline(flag)
                responses.append(parse_response(p.recvline(), flag))

            p.close()

            return responses

        except requests.ConnectionError as e:
            log.failure("Submission server is not up. Re-trying in {} seconds".format(
                RECONNECT_DELAY))
            time.sleep(RECONNECT_DELAY)

        except requests.ReadTimeout as e:
            log.failure("Submission server did not respond in {} seconds. Re-trying.".format(
                REQUEST_TIMEOUT))

        except Exception as e:
            log.failure("An unknown error occured when submitting the flags : {}".format(e))

        time.sleep(1)


def register_handlers(path = EXPLOIT_FOLDER):
    """
    Register exploit handlers from the exploit folder
    Returns the list of registered handlers
    """

    exploit_folder = './{}/{}'.format(os.path.dirname(__file__), path)
    handlers = []

    for module in os.listdir(exploit_folder):

        if not module.endswith(".py") or module == "__init__.py":
            continue

        # Execute the script
        # We assume that each executed script registers himself to the handlers dictionary.
        try:
            execfile('./{}/{}'.format(path, module))
        except Exception as e:
            log.failure("Could not register handler '{}' : {}".format(module, e))

    log.info("Registered {} handler(s).".format(len(handlers)))
    for handler in handlers:

        handler_name = handler.__name__
        log.info("- Registered '{}' handler".format(handler_name))

    return handlers


if __name__ == '__main__':

    log.info("Starting exploit throwing framework...")

    # Main round loop
    while True:

        log.header("==== ROUND START ====")

        # Register handlers
        handlers = register_handlers()
        services_and_handlers = {}
        for handler in handlers:
            services_and_handlers[handler.SERVICE_NAME] = handler

        # Dictionary containing a list of flags for each handler
        flags_per_handler = {}

        # Keep track of errors for this round
        errors = set()

        # Get service infos
        log.info("Fetching services infos...")
        attacc = {}
        try:
            r = requests.get(ATTACC_URL)
            attacc = r.json()
        except Exception as e:
            log.failure('cant fetch attack.json : {}'.format(e))

        # Load targets
        log.info("Loading targets...")
        targets = []
        opponents_ips = attacc["availableTeams"]

        for service in services_and_handlers.keys():
            for opponent_ip in opponents_ips:
                try:
                    handler = services_and_handlers[service]
                    targets += [(handler, {
                        "hostname": opponent_ip,
                        "infos": attacc.get("services", {}).get(service, {}).get(opponent_ip, []),
                    })]
                except Exception as e:
                    log.failure('{} : {}'.format(handler.__name__, e))

        def exploit((handler, target)):
            handler_name = handler.__name__
            opponent_ip = target['hostname']
            infos = target['infos']

            results = []
            # Run each exploit
            try:
                flags = handler.get_flags(opponent_ip, infos)
                if flags != None:
                    results += [(handler_name, flag.strip()) for flag in flags]

            except Exception as e:
                error_message = "Service '{}' failed to get flag(s) : {}".format(
                        handler_name, e)

                log.fail_once(error_message, errors)
                errors.add(error_message)

            return results

        log.info("Submitting flags...")
        pool = ThreadPool(100)
        results = pool.map(exploit, targets)
        pool.close()
        pool.join()

        for l in results:
            for pair in l:
                flags = flags_per_handler.get(pair[0], [])
                flags.append(pair[1])
                flags_per_handler[pair[0]] = flags

        # Log number of flags per handler
        all_flags = []
        for handler in flags_per_handler.keys():

            flags = flags_per_handler.get(handler, [])
            log.success("'{}' handler found {} flag(s).".format(handler, len(flags)))

            all_flags.extend(flags)

        # Filter out flags with incorrect format
        filtered_flags = remove_invalid_flags(all_flags)

        # Send flags to submission server
        flag_responses = submit_flags(filtered_flags)

        # Print statistics
        print_statistics_from_flag_responses(flag_responses, flags_per_handler)

        # Wait for next round
        seconds_left = 60
        log.info("Waiting {} seconds before next round".format(seconds_left))
        time.sleep(seconds_left)
